# Java Foundation

### Basic concepts

###### Features of Java language

- **Simple and easy to learn:** Java language has a syntax that is similar to C++ language but without many of its complex features. This makes it easier for programmers to learn and write code in Java. 

- **Object-oriented:** Java is an object-oriented programming language that supports encapsulation, inheritance, and polymorphism. 

- **Platform independence:** Java programs can run on any platform that has a Java Virtual Machine (JVM) installed after once complie. 

- **Support for multithreading:** Java has built-in support for multithreading. 

- **Reliability:** Java programs are more reliable compared to other programming languages because of its strict compile-time checking for syntax and run-time checking for memory allocation and deallocation. 

- **Security:** Java is a highly secure programming language as it runs inside a virtual machine that prevents any unauthorized access to the system. 

- **Support for network programming:** Java language was designed with network programming in mind. 

- **Coexistence of compilation and interpretation:** Java programs are compiled into bytecode, which is then interpreted by the JVM at runtime.

###### JVM, JRE, JDK
- **JVM:** Java Virtual Machine is an abstract computing machine that provides a runtime environment to execute Java bytecode. It interprets the bytecode and converts it into machine code that can be executed by the host operating system.

- **JRE:** Java Runtime Environment is a software package that contains everything required to run a Java program, including the JVM, class libraries, and other supporting files.

- **JDK:** Java Development Kit is a software development kit that contains everything required to develop and run Java applications, including the JRE, the JVM, and development tools such as a compiler, debugger, and documentation.


###### What is the bytecode and its advantage

- **Bytecode:** is an intermediate code that is generated by a compiler before the source code of a program is translated into machine code.

- **Procedure:** .java -> javac complie -> .class -> interpreter & JIT -> machine code
    1. .class -> machine code, this step JVM load the bytecode, and interpret it line by line, it waste some time. So JIT can save hot bytecode as machine code. If execute this code again, it can directly run the machine code. 
    2. JDK9 introduce AOT(Ahead Of Time Compilation). Compile the bytecode to machine code directly. Prevent the pre-warm of JIT. JDK support compile by layer cooperate with AOT.

- **Advantages:**
    1. **Platform independence && Portability:** Bytecode is designed to be executed by a virtual machine, which means that it can run on any platform that has the appropriate VM installed.
    2. **Security:** Bytecode is a form of intermediate code, Which means that it is not directly executable by a computer's hardware. This provides an extra layer of security for programs because bytecode can be verified and checked for security issues before it is executed.
    3. **Efficiency:** Bytecode is often more compact than machine code, which means that it can be transmitted over a network or stored on a disk more efficiently. This can result in faster program execution times and reduced storage requirements.
    4. **Performance:** Java bytecode is compiled just once, and then executed on the JVM, This can result in better performance than interpreted language. 

###### Why don't we alway use AOT
- **Advantage:**
    1. **Faster startup time:** AOT compilation can improve the startup time of Java applications because the compiled code is ready to execute immediately, without the need for just-in-time (JIT) compilation.
    2. **Improved performance:** By compiling Java code ahead of time, the native code can be optimized for the specific hardware and operating system, potentially leading to improved performance.
    3. **Lower memory usage:** AOT compilation can reduce the memory usage of a Java application because it eliminates the need to store JIT-compiled code in memory.
- **Not always the best choice:**
    1. if your application uses dynamic class loading or reflection, AOT compilation may not work as expected
    2. AOT compilation can increase the size of the compiled code, which can be a disadvantage in certain scenarios
- It's depends on the specific requirements and characteristics of your application

###### Why we say Java is coexistence of compilation and interpretation?
- **Compiled language:** It translates the source code into machine code in one go. It run fast, but develop slow.
- **Interpreted language:** It translates the source code into machine code line by line. It run slow, but develop fast.
- **Java:** However, Java compile to the bytecode first, then interpret to the machine code. It combines both feature.

###### Oracle JDk vs Open JDK
- two different implementations of the Java SE (Standard Edition) platform specification.
- Oracle JDK is a commercial implementation of the Java SE platform that is developed and supported by Oracle Corporation. It includes additional proprietary features such as Java Flight Recorder and Java Mission Control that are not available in OpenJDK.
- On the other hand, OpenJDK is a free and open-source implementation of the Java SE platform that is developed by the OpenJDK community. It is maintained by several companies and individuals, and it includes all the features required to run Java applications. OpenJDK is the reference implementation of Java SE, and it is used as the basis for many other Java implementations.
- Oracle JDK is licensed under the Oracle Binary Code License (BCL), which includes some restrictions on commercial use and redistribution. OpenJDK, on the other hand, is licensed under the GNU General Public License (GPL), which allows for unrestricted use and distribution of the software.

###### Difference between Java and C++
- Platform: Java is a platform-independent language, meaning that Java programs can run on any platform that has a Java Virtual Machine (JVM) installed. C++ is platform-dependent, meaning that compiled C++ programs can only run on the platform they were compiled for.

- Memory management: Java uses automatic memory management, which means that the Java Virtual Machine automatically manages memory allocation and deallocation for objects. C++ requires manual memory management, meaning that the programmer is responsible for allocating and deallocating memory for objects.

- Syntax: Java has a simpler syntax compared to C++. Java is also a strongly typed language, which means that every variable must be declared with a specific data type. C++ has a more complex syntax, and it allows for both strongly typed and weakly typed programming.

- Object-oriented programming: Both Java and C++ are object-oriented programming languages, but Java has stricter rules for object-oriented programming. Java requires all code to be written within a class, whereas C++ does not have this requirement.

- Performance: C++ is generally faster than Java, as C++ code is compiled to machine code, while Java code is compiled to bytecode, which is then interpreted by the JVM. However, Java's just-in-time (JIT) compilation can sometimes improve performance.

- Libraries: Java has a larger standard library than C++, and it also has a large number of third-party libraries available. C++ also has a large standard library, but it may require additional libraries for certain tasks.

### Java basic syntax
###### What types of java comment?
- Single-line comments: These are comments that begin with two forward slashes (//) and extend to the end of the line. Single-line comments are used to provide short, explanatory comments about a line of code.

- Multi-line comments: These are comments that begin with /* and end with */. Multi-line comments can span multiple lines and are used to provide longer, more detailed comments about a section of code.

- Javadoc comments: These are special comments that begin with /** and end with */. Javadoc comments are used to generate documentation for classes, interfaces, methods, and fields. Javadoc comments can include tags such as @param, @return, and @throws to provide additional information about the documentation.

###### Difference between identifier and keyword in java?
- an identifier is a name given to a variable, method, class, interface, or other program element. It is used to uniquely identify the element in the program. Identifiers can be composed of letters, digits, and underscores (_), and must start with a letter or underscore. 
- a keyword is a reserved word in the Java programming language that has a specific meaning and purpose. Keywords cannot be used as identifiers because they are already used by the language for specific purposes. 
- keywords:

| Type         | Keyword      | 
|--------------|--------------|
| Access Modifiers | public   | 
|                | private  | 
|                | protected|
|--------------|--------------|
| Control Flow | if          | 
|              | else        | 
|              | switch      |
|              | case        |
|              | default     |
|              | break       |
|              | continue    |
|              | return      |
|--------------|--------------|
| Classes and Objects | class     |
|                      | new       |
|                      | this      |
|                      | super     |
|                      | abstract  |
|                      | final     |
|                      | interface |
|                      | implements|
|                      | extends   |
|                      | instanceof|
|--------------|--------------|
| Data Types   | boolean  | 
|              | byte     | 
|              | char     | 
|              | double   | 
|              | float    | 
|              | int      | 
|              | long     | 
|              | short    | 
|              | void     |
|--------------|--------------|
| Exception Handling | try    |
|                     | catch  |
|                     | finally|
|                     | throw  |
|                     | throws |
|--------------|--------------|
| Modifiers    | static   | 
|              | final    | 
|              | abstract | 
|              | synchronized |
|              | transient |
|              | volatile  |
|--------------|--------------|
| Others | package   |
|               | import    |
|               | native    |
|               | assert    |

###### Auto-increment and Auto-decrement operational character in Java
- In Java, the auto-increment and auto-decrement operators are used to increment or decrement the value of a variable by 1. The auto-increment operator (++) is used to increase the value of the variable by 1, while the auto-decrement operator (--) is used to decrease the value of the variable by 1.
- When used as a postfix operator, the variable is first used in the expression, and then incremented or decremented
- When used as a prefix operator, the variable is incremented or decremented first, and then used in the expression

###### Shift operator in java
- In Java, shift operators are used to shift the bits of a binary number to the left or right by a specified number of positions. There are three shift operators in Java: left shift operator (<<), signed right shift operator (>>), and unsigned right shift operator (>>>).
- The left shift operator (<<) shifts a number's binary representation to the left by a specified number of positions and fills the low-order bits with zeros. 
- The signed right shift operator (>>) shifts a number's binary representation to the right by a specified number of positions and preserves the sign bit.
- The unsigned right shift operator (>>>) also shifts a number's binary representation to the right by a specified number of positions, but it does not preserve the sign bit. 
- It's important to note that shift operators can only be used with integer types (byte, short, int, long) of data.

###### Difference between continue, break and return?
- continue, break, and return are three different keywords in Java used to control the program's flow. Their differences are:
    1. continue: Used in a loop to skip the current iteration and jump to the next iteration of the loop. The statements after the continue keyword in the loop are not executed, and the loop continues with the next iteration.

    2. break: Used in a loop or switch statement to terminate the loop or switch statement. Once the break statement is executed, the program control jumps to the next statement after the loop or switch block.

    3. return: Used in a method to return a value to the calling code and terminate the method's execution. Once the return statement is executed, the program control is transferred to the calling code. If the method has a return type, it must return a value of the specified type.

###### instance variables and local variables
- Instance variables, also known as member variables, are defined within a class but outside of any method. They are associated with an object of the class and are initialized when the object is created. Instance variables have a default value, which is null for reference types and 0 or false for primitive types, if they are not explicitly initialized.

- Local variables, on the other hand, are declared within a method or a block of code and are only accessible within that method or block. They must be explicitly initialized before they can be used, and they do not have a default value. Local variables are stored in the stack memory and are automatically removed when the method or block of code is finished executing.

- The main differences between instance variables and local variables are:

    1. Scope: Instance variables have a class scope, which means they are accessible throughout the entire class. Local variables have a block scope, which means they are only accessible within the block of code where they are declared.

    2. Lifetime: Instance variables are created when an object is created and destroyed when the object is destroyed. Local variables are created when a method or block of code is executed and destroyed when the method or block of code is finished executing.

    3. Default values: Instance variables have default values, while local variables do not.

    4. Access modifiers: Instance variables can have access modifiers (public, private, protected), while local variables cannot.

- Overall, instance variables represent the state of an object, while local variables are used for temporary storage of data within a method or block of code.

###### Static variable in Java
- In Java, a static variable is a variable that belongs to the class and not to any instance of the class. This means that the variable is shared by all instances of the class and can be accessed without creating an instance of the class.

- Static variables can be useful for several purposes in Java, such as storing constants, maintaining a count of the number of objects created from a class, or storing global configuration values. They can also be used to implement the singleton design pattern, which ensures that only one instance of a class is created.

- Another advantage of static variables in Java is that they are initialized only once, at the start of the program, and retain their value across multiple function calls. This can help to reduce memory usage and improve program performance.

- In summary, static variables in Java provide a way to store and access data that is shared by all instances of a class and can be useful for implementing various design patterns, maintaining global state, and optimizing program performance.

###### character literals and string literals (constant)
- Character literals are a single character enclosed in single quotes, such as 'a' or '9'. They represent a single character and are of type char.

- String literals are a sequence of characters enclosed in double quotes, such as "hello" or "123". They represent a sequence of characters and are of type String.

- The main difference between character literals and string literals is that character literals represent a single character, whereas string literals represent a sequence of characters.

- Another difference is that character literals are enclosed in single quotes, while string literals are enclosed in double quotes.

- Finally, character literals are of type char, while string literals are of type String.

- In summary, character literals and string literals are both types of constants in Java, but they differ in the number of characters they represent and the way they are enclosed.

###### Why static methods can't use non-static members?
- In Java, static methods belong to the class itself rather than to a specific instance of the class. This means that static methods can be called without creating an object of the class.

- On the other hand, non-static members (such as instance variables and methods) are associated with a particular instance of the class. In order to access these members, you need to first create an object of the class.

- Since static methods can be called without an object, they do not have access to non-static members. This is because non-static members require an instance of the class to be accessed, and a static method doesn't have access to any particular instance.

- Therefore, if a static method tried to access a non-static member, it wouldn't know which instance of the class to access the member from. This is why static methods cannot call non-static members directly.

###### Difference between instance methods and static methods
- Static methods are associated with the class, while instance methods are associated with instances (objects) of the class. This means that static methods can be called on the class itself, while instance methods can only be called on instances of the class.

- Static methods can access only static data members of the class, while instance methods can access both static and non-static data members.

- Static methods can be called without creating an instance of the class, while instance methods can only be called on an instance of the class.

- Static methods cannot be overridden by subclasses, while instance methods can be.

- Static methods are resolved at compile time based on the class of the object reference, while instance methods are resolved at runtime based on the type of the object.

- Overall, static methods are useful for operations that do not depend on any specific instance of the class, while instance methods are used for operations that require access to specific instance data.

###### Difference between overloading and overriding in java
- Overloading is a feature in Java that allows methods with the same name to coexist in the same class. Overloaded methods must have different parameter lists (either in terms of number or type of parameters). On the other hand, overriding is a feature that allows a subclass to provide its own implementation of a method that is already defined in its superclass.

- Overloaded methods are differentiated based on the number and types of their parameters, while overridden methods must have the same name, return type, and parameter list as the method they are overriding.

- Overloading is resolved at compile-time based on the number and types of arguments passed to the method, while overriding is resolved at runtime based on the actual object type.

- Overloading is used to provide different ways to invoke the same method with different arguments, while overriding is used to provide a new implementation of a method that behaves differently than its superclass implementation.

- Overloading can occur in the same class or in different classes in the same inheritance hierarchy, while overriding can only occur between a subclass and its superclass.

- Overall, overloading is used to provide multiple methods with the same name but different functionality, while overriding is used to provide a new implementation of an existing method in a subclass.

###### variable-length arguments
- In Java, variable-length arguments, also known as varargs, allow a method to accept a variable number of arguments of the same type. The syntax for varargs is to use an ellipsis (three dots) after the type of the parameter
- Varargs are useful when you don't know how many arguments a method will need to accept at runtime.

### primitive data type
###### types in Java
| 基本类型 | 位数 | 字节 | 默认值 | 取值范围 |
|----------|-----|------|-------|---------|
| boolean  | 1   | 1    | false | true/false |
| byte     | 8   | 1    | 0     | -2^7 到 2^7-1 |
| short    | 16  | 2    | 0     | -2^15 到 2^15-1 |
| int      | 32  | 4    | 0     | -2^31 到 2^31-1 |
| long     | 64  | 8    | 0L    | -2^63 到 2^63-1 |
| float    | 32  | 4    | 0.0f  | 2^-149 到 (2-2^-23) x 2^127 |
| double   | 64  | 8    | 0.0d  | 2^-1074 到 (2-2^-52) x 2^1023 |
| char     | 16  | 2    | '\u0000' | '\u0000' 到 '\uffff' |

###### Difference between primitive types and wrapper class

- In Java, the main difference between primitive types and wrapper classes is that primitive types are basic data types that are not objects, while wrapper classes are classes that encapsulate primitive types and provide additional functionality.

- Primitive types are predefined data types in Java that represent simple values, such as integers, floating-point numbers, booleans, and characters. They are typically represented using keywords, such as int, float, boolean, and char, and can be used directly in Java code without needing to be instantiated.

- Wrapper classes, on the other hand, are classes in Java that provide an object representation of primitive types. They are used to provide additional functionality and methods that are not available with primitive types, such as conversion to and from strings, and comparison using the equals() method. Wrapper classes include Integer, Double, Boolean, and Character, among others.

- One important difference between primitive types and wrapper classes is that primitive types are passed by value, whereas wrapper classes are passed by reference. This means that when a primitive type is passed as an argument to a method, a copy of its value is created and passed to the method, while when a wrapper class is passed as an argument, a reference to the object is passed instead.

- Another difference is that primitive types have a fixed size and range of values, while wrapper classes can represent a wider range of values and have methods to check and manipulate their values.

- Local variables of primitive data types are stored in the local variable table of the Java Virtual Machine stack, while instance variables of primitive data types (not marked as static) are stored in the heap of the Java Virtual Machine. Wrapper types belong to object types, and we know that almost all object instances exist in the heap.

- In summary, while primitive types are basic data types that are not objects, wrapper classes are classes that encapsulate primitive types and provide additional functionality. Primitive types are passed by value, while wrapper classes are passed by reference, and wrapper classes can represent a wider range of values and have additional methods.

###### Escape analysis
- Escape Analysis is an optimization technique used in Java Virtual Machine (JVM) to determine whether objects allocated on the heap are accessible outside their scope, which means whether they "escape" from their method or thread. If the objects do not escape, they can be optimized by allocating them on the stack instead of the heap.

- The Escape Analysis in Java can greatly improve the performance of the application by reducing the overhead of garbage collection and heap memory usage. It also enables the JVM to apply other optimizations such as lock coarsening, lock elision, and scalar replacement.

- The Escape Analysis works by analyzing the bytecode and the usage of the objects to determine their scope. If an object is found to be used only within a method or thread, the JVM allocates it on the stack. However, if the object is used outside its scope or passed as a parameter to another method, it has to be allocated on the heap.

- Escape Analysis is enabled by default in modern JVMs, but it can be disabled using the "-XX:-DoEscapeAnalysis" flag. However, disabling it can lead to worse performance due to increased heap memory usage and garbage collection overhead.

- In summary, Escape Analysis is an important optimization technique in Java that can greatly improve the performance of the application by reducing heap memory usage and garbage collection overhead.

###### Caching mechanism for wrapper types
- In Java, there is a caching mechanism for wrapper types, which is called the "wrapper class cache". This mechanism is designed to improve performance and reduce memory usage, especially in situations where a large number of wrapper objects are created.

- The wrapper class cache works by maintaining a cache of frequently used wrapper objects, such as Integer objects for small integers or Boolean objects for true and false values. When a new wrapper object is needed, the cache is first checked to see if an object with the requested value already exists. If such an object is found in the cache, it is returned instead of creating a new object.

- The cache is implemented as a static array in each wrapper class, with a size of 256 for Integer, Short, Byte, and Long classes, a size of 128 for  Character class and a size of 2 for Boolean class. The range of values that are cached varies depending on the wrapper class.

- It is important to note that the wrapper class cache is an implementation detail of the Java runtime, and its behavior may vary depending on the version of Java and the JVM being used. Therefore, it is not recommended to rely on the cache for application logic, and wrapper objects should be compared using the equals() method instead of the "==" operator.

###### Auto-boxing and auto-unboxing in Java
- In Java, auto-boxing and auto-unboxing are features that allow automatic conversion between primitive data types and their corresponding wrapper types. Auto-boxing refers to the automatic conversion of a primitive data type to its wrapper type, while auto-unboxing refers to the automatic conversion of a wrapper type to its corresponding primitive data type.

- Auto-boxing is useful when a method expects an object of a wrapper type, but a primitive value is available instead. The Java compiler automatically converts the primitive value to the corresponding wrapper object, eliminating the need for explicit object creation. 

- Auto-unboxing works in the opposite direction, converting a wrapper object to its corresponding primitive value. This is useful when a method expects a primitive value, but a wrapper object is available instead. 

- Auto-boxing and auto-unboxing are convenient features, but they can have performance implications if used excessively. When auto-boxing or auto-unboxing occurs, a new object is created or a method call is made, which can add overhead to your code. Therefore, it is recommended to use them judiciously and be aware of their impact on your application's performance.

###### Why floating-point arithmetic can sometimes result in loss of precision 
- In Java, floating-point arithmetic can sometimes result in loss of precision due to the way floating-point numbers are represented in binary. Floating-point numbers are represented as a combination of a sign, a mantissa, and an exponent, with a fixed number of bits allocated for each component.

- The problem is that some decimal numbers, such as 0.1, cannot be represented exactly in binary, just as 1/3 cannot be represented exactly in decimal. Therefore, when these numbers are used in calculations, they may be rounded or truncated, leading to small errors that can accumulate over time.For example, consider the following code:
    ```
    float x = 0.1f;
    float y = 0.2f;
    float z = x + y;
    System.out.println(z);
    ```
- The expected output is 0.3, but the actual output may be something like 0.300000012. This is because the numbers 0.1 and 0.2 cannot be represented exactly in binary, and when they are added, a small error is introduced.
- To minimize the risk of precision loss, it is recommended to use the BigDecimal class for calculations that require high precision. The BigDecimal class represents decimal numbers as a sequence of digits with a fixed number of decimal places, and provides methods for precise arithmetic operations. However, BigDecimal operations may be slower than floating-point operations, so they should be used only when necessary
- equals() method of BigDecimal compare both value and scale whereas compareTo() method only compare value.
###### How to represent the data that exceeds the range of the long data type
- In Java, data that exceeds the range of the long data type can be represented using the BigInteger class. The BigInteger class is a part of the java.math package, and it provides a way to represent arbitrarily large integers.

- The BigInteger class represents integers as an array of digits, and it provides methods for performing arithmetic operations, such as addition, subtraction, multiplication, and division. BigInteger also supports operations for bitwise operations, modular arithmetic, and prime number generation.

- To create a BigInteger object, you can use one of its constructors that takes a String, a byte array, or a long value as an argument. For example, to create a BigInteger object with the value 12345678901234567890, you can use the following code:
    ```
    BigInteger num = new BigInteger("12345678901234567890");
    ```
- Once you have a BigInteger object, you can perform arithmetic operations on it using the methods provided by the BigInteger class. For example, to add two BigInteger objects, you can use the add() method:
    ```
    BigInteger num1 = new BigInteger("12345678901234567890");
    BigInteger num2 = new BigInteger("98765432109876543210");
    BigInteger sum = num1.add(num2);
    ```
- It is important to note that operations on BigInteger objects may be slower than operations on primitive data types, due to the overhead of manipulating large arrays of digits. Therefore, BigInteger should be used only when necessary, and operations on BigInteger objects should be optimized for performance.

### Basis of Object-oriented
###### Difference between Object-oriented and procedural programming
- Object-oriented programming (OOP) and procedural programming are two different programming paradigms. In procedural programming, a program is seen as a series of procedures or functions that are executed in sequence to achieve the program's functionality. In contrast, in object-oriented programming, a program is seen as a collection of objects that interact to achieve the program's functionality.

- Procedural programming is a task-based programming approach that emphasizes the design of algorithms and data structures and focuses on the implementation details of the program. Typically, program data and methods are stored separately, and this separation can result in code that is more difficult to read and maintain.

- In contrast, object-oriented programming is a more modular programming approach that emphasizes the organization of code into objects that encapsulate data and behavior. Objects interact with each other through defined interfaces, and the implementation details of an object are hidden from other objects. This can lead to code that is more modular, reusable, and easier to understand and maintain.

###### How to create an object? Difference between object entity and object reference
- To create an object in Java, you use the "new" operator.
- An object entity in Java is an instance of a class that occupies memory and has state and behavior. An object reference is a variable that stores the memory address of an object.

- In other words, an object entity represents the actual object in memory, while an object reference is simply a variable that points to the object in memory. When you assign an object reference to another variable, you are creating a copy of the reference, but both references point to the same object entity in memory.

###### Difference between object equality and reference equality
- Reference equality checks whether two object references refer to the same object instance in memory. In other words, it checks if the two references point to the exact same memory location. This can be done using the "==" operator.

- Object equality, on the other hand, checks whether two objects have the same value or state. This requires the implementation of the equals() method in the class of the objects being compared. This method should compare the state of the objects and return true if they are equal, and false otherwise.

- It's important to note that two objects can be equal in terms of their values or state, but not equal in terms of their references. For example, if you create two separate String objects with the same value, their references will not be equal, but they will be considered equal in terms of object equality.

- In summary, reference equality checks whether two object references refer to the same object instance in memory, while object equality checks whether two objects have the same value or state.

###### Purpose of Class Constructors in Java
- In Java, a class constructor is a special method that is called when an object of the class is created using the new keyword. The constructor is used to initialize the state of the object and prepare it for use.
- One of the main purposes of a constructor is to ensure that the object is initialized with a valid state, which means that all of its instance variables have been assigned a value.
- Another important purpose of a constructor is to provide flexibility in creating objects by allowing the caller to specify values for the instance variables during object creation.
- Constructors can also be used to perform other initialization tasks that are necessary for the object to function properly, such as allocating resources or setting up connections to external systems.
- In Java, a class can have multiple constructors, each with a different set of parameters. This allows objects to be created with different initial states, depending on the needs of the caller.
- The name of the constructor is always the same as the name of the class, and it does not have a return type. This distinguishes it from other methods in the class.
- If a class does not have any explicit constructors defined, Java will provide a default constructor that takes no arguments and does not perform any initialization.

###### Object-oriented Programming (OOP) - Three Main Features
- Encapsulation: Encapsulation is the ability to hide internal details and complexities of an object from the outside world, and to only expose the essential features and methods of the object. This helps to improve the reliability, maintainability, and scalability of a program.

- Inheritance: Inheritance is the ability of a class to inherit properties and methods from its parent class or super class. This allows for code reuse and reduces the amount of code that needs to be written, making programs more efficient and easier to maintain.

- Polymorphism: Polymorphism is the ability of an object to take on many forms or shapes. In Java, this is achieved through method overriding and overloading. Polymorphism allows for flexibility in programming and enables different objects to be used interchangeably, as long as they implement the same interface or superclass.

###### Similarities and Differences between Interface and Abstract Class in Java
- All can't be instantiated.
- All can contain the abstract methods.
- All can contain the default methods.
- Interface foucs on restricting the behaviour of class. Abstract class foucs on code reusable, emphasis ownership.
- One class can only extend one class, but implement multiple interface.
- Member vairables of interface can only be public static final, can't be modified and must have a default value. In abstract class, member variables can be default, can be redefine in subclass, can be reassigned value.

###### Understanding the difference between Shallow Copy and Deep Copy in Java
- Shallow Copy creates a new object and copies all the fields of the original object to the new object. However, if the original object contains reference variables, the reference variables are not copied; instead, they are simply copied to the new object. This means that both the original object and the new object will point to the same object in memory.

- Deep Copy creates a new object and copies all the fields of the original object to the new object, including the reference variables. In this way, a completely new object is created with its own memory space, and any changes made to the new object will not affect the original object.

- Reference Copy is a mechanism in Java where a new variable is created, and it points to the same object that another variable is pointing to. In this way, two or more variables can refer to the same object in memory. Any changes made to one variable will be reflected in all the other variables that are pointing to the same object.

### Java common class
###### Common Methods of the Object Class in Java
- equals(Object obj): This method is used to compare the current object with the specified object to check if they are equal.
- hashCode(): This method returns a hash code value for the object. It is typically used in hash tables.
- toString(): This method returns a string representation of the object. It is commonly used for debugging and logging.
- getClass(): This method returns the runtime class of an object.
- notify(): This method wakes up a single thread that is waiting on the object's monitor.
- notifyAll(): This method wakes up all threads that are waiting on the object's monitor.
- wait(): This method causes the current thread to wait until another thread invokes the notify() or notifyAll() method for this object.
- wait(long timeout): This method causes the current thread to wait for a specified amount of time until another thread invokes the notify() or notifyAll() method for this object, or until the specified timeout has elapsed.
- wait(long timeout, int nanos): This method causes the current thread to wait for a specified amount of time plus a specified number of nanoseconds until another thread invokes the notify() or  notifyAll() method for this object, or until the specified timeout has elapsed.

###### Difference between == and equals() in Java
- In Java, the == operator is used to compare the reference values of two objects. It checks whether two object references point to the same memory location or not.
- On the other hand, the equals() method is used to compare the contents of two objects. It compares the values of the variables inside the objects, rather than the memory location.
- == can be used to compare primitive data types and objects, while equals() can only be used to compare objects.
- == is faster than equals() since it only compares reference values, while equals() may have to compare the contents of the objects.
- == is a binary operator while equals() is a method.

###### What is the purpose of hashCode() in Java?
- In Java, the hashCode() method is used to generate a hash code value for an object. 
- Hash codes are used in hash-based data structures like hash tables and hash maps. These data structures use the hash code to determine the index at which an object is stored in the table or map. This allows for fast lookup and insertion of objects.
- hashCode() is used in conjunction with the equals() method. If two objects are equal (as determined by the equals() method), then their hash codes must also be equal. This ensures that equal objects have the same hash code and can be found in a hash-based data structure.
- hashCode() is used in some algorithms like sorting and searching to improve performance. By using the hash code of an object, the algorithm can quickly determine whether two objects are likely to be equal or not.
- hashCode() is used in object identity testing. Two objects that are identical (i.e., they refer to the same memory location) will have the same hash code.

###### Why is it necessary to override the hashCode() method when overriding equals() in Java?
- In Java, the equals() method is used to determine whether two objects are equal, while the hashCode() method is used to generate a hash code value for an object. Here are some of the reasons why it is necessary to override the hashCode() method when overriding equals():

- The equals() method and hashCode() method are closely related. According to the contract between the two methods, if two objects are equal, their hash codes must also be equal. This means that if you override the equals() method without overriding the hashCode() method, the contract may be violated and the behavior of hash-based data structures like hash maps and hash sets may become unpredictable.
- When two objects are inserted into a hash-based data structure like a hash map, they are stored in different locations based on their hash codes. If the hashCode() method is not overridden, two objects that are equal may have different hash codes, causing the hash-based data structure to store them in different locations. This can result in unexpected behavior when retrieving the objects from the data structure.
- The default implementation of hashCode() in the Object class generates a unique hash code for each object based on its memory location. If you override the equals() method without overriding the hashCode() method, two objects that are equal may have different hash codes since their memory locations are different. This can cause hash-based data structures to store the objects in different locations, resulting in unexpected behavior.
- In summary, it is necessary to override the hashCode() method when overriding the equals() method in order to ensure that the contract between the two methods is maintained and to ensure proper behavior of hash-based data structures.

###### Differences between String, StringBuffer, and StringBuilder in Java
- In Java, String, StringBuffer, and StringBuilder are all used to represent sequences of characters. Here are some of the key differences between these three classes:

- String is an immutable class, which means that its contents cannot be changed once it is created.Any operation that modifies a String object actually creates a new String object, which can be inefficient in terms of memory usage and performance.
- String objects are thread-safe, which means that they can be accessed by multiple threads without the risk of data corruption.
- StringBuffer is a mutable class, which means that its contents can be changed after it is created. Any operation that modifies a StringBuffer object does not create a new object. Instead, it modifies the existing object in place.
- StringBuffer objects are thread-safe, which means that they can be accessed by multiple threads without the risk of data corruption.
- StringBuilder is similar to StringBuffer in that it is a mutable class and its contents can be changed after it is created.
- The main difference between StringBuilder and StringBuffer is that StringBuilder is not thread-safe, which means that it cannot be accessed by multiple threads simultaneously without the risk of data corruption.
- Because StringBuilder is not thread-safe, it can be faster than StringBuffer in certain situations.
- Overall, the choice between String, StringBuffer, and StringBuilder depends on the specific requirements of your application. If you need to represent a sequence of characters that cannot be modified, use String. If you need to represent a sequence of characters that can be modified and accessed by multiple threads, use StringBuffer. If you need to represent a sequence of characters that can be modified but will only be accessed by a single thread, use StringBuilder for optimal performance.
- After Java9, the implementation of String transform from char array to byte array. Cause new String support Latin-1 and UTF-16 encoding. In Latin-1 encoding, byte occupy 1 byte, char occupy 2 byte. And most String objects contain only Latin-1 characters. So it can save the memory usage.
- Using + operator is actually using append method in StringBuilder.
### Exception


### 

